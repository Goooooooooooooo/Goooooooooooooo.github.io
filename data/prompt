你现在的角色是“表单运行时系统实现工程师（Form Runtime System Engineer）”。

你的任务是：实现一个完整的 Form Runtime 体系，用于增强现有基于 ui-config 的表单渲染系统。
当前项目中已经存在 ui-config → Form 的渲染逻辑，你的实现必须可以无侵入集成，
不得要求重写或替换现有表单渲染实现。

====================
【总体目标】
====================

- 在页面级别通过 Provider 启用表单运行时能力
- 在字段渲染阶段注册字段、校验规则、业务规则
- 在运行时根据 onChange / onBlur / onSubmit 统一调度规则
- UI 组件保持“无业务逻辑、无校验逻辑”

====================
【不可协商的架构约束】
====================

1. Zod 校验
- Zod schema 仅在表单初始化阶段构建一次
- 通过统一入口执行校验（不得在 Field 或 UI 层执行）
- Zod 校验不属于 UI 或 Field 组件职责

2. Business Rule（业务规则）
- 以 JavaScript 脚本形式声明在 ui-config 中
- 在字段渲染阶段只进行注册，不得执行
- 只能由中央 Form Runtime 统一调度执行
- 支持触发时机：onChange / onBlur / onSubmit
- 脚本必须通过受控 Function 执行，禁止使用 eval

3. Field（字段集成点）
- Field 不是新的表单体系，只是“注册壳”
- 可作为组件或函数形式存在
- 只负责在渲染阶段向 Runtime 注册字段配置
- 不包含任何校验或业务规则执行逻辑

4. Form Runtime Provider
- 页面级启用运行时能力
- 使用 React Context 提供 Runtime 实例
- Provider 本身不渲染任何表单 UI
- 未被 Provider 包裹时，useFormRuntime 必须抛出错误

5. 与现有系统的关系
- 不修改现有 ui-config 结构
- 不修改现有 Form Renderer 的核心逻辑
- 仅通过包裹 Provider / 注册壳完成集成

====================
【接口定义（不可修改）】
====================

```ts
interface FieldConfig {
  name: string;
  zod?: ZodTypeAny;
  businessRules?: BusinessRule[];
}

interface BusinessRule {
  trigger: "onChange" | "onBlur" | "onSubmit";
  watch?: string[];
  script: string;
}
```

====================
【系统组成（必须全部实现）】
	1.	FormRuntimeCore

	•	字段注册 / 注销
	•	Business Rule 注册表（按 trigger + watch 组织）
	•	规则调度与执行
	•	防止重复执行与基础循环保护

	2.	FormRuntimeProvider

	•	创建并持有唯一 Runtime 实例
	•	管理 Runtime 生命周期
	•	通过 Context + Hook 暴露 Runtime

	3.	useFormRuntime Hook

	•	仅允许在 Provider 内使用
	•	Provider 外调用必须抛出明确错误

	4.	Zod 校验集成

	•	在 Runtime 初始化阶段构建 schema
	•	提供统一校验执行入口
	•	校验在 submit 或指定时机执行

	5.	Field 注册方案（至少提供一种）

	•	组件形式（如 FormField）
或
	•	函数式集成到现有 renderField / renderForm 中
【使用方式示例（不可修改语义）】

页面级启用：
<FormRuntimeProvider>
  {renderForm(uiConfig)}
</FormRuntimeProvider>

字段渲染阶段注册（示例之一）：
runtime.registerField(fieldConfig);

====================
【实现顺序（必须严格遵守）】

Step 1：
实现 FormRuntimeCore（不涉及 UI，不涉及 React）

Step 2：
实现 FormRuntimeProvider 与 useFormRuntime（Context + 生命周期）

Step 3：
集成 Zod 校验调度逻辑

Step 4：
实现 Business Rule 执行机制（onChange / onBlur / onSubmit）

Step 5：
展示如何与现有 ui-config Form 渲染系统集成（最小示例）

====================
【输出要求】
	•	输出完整实现代码（按模块拆分）
	•	代码需可读、可维护
	•	不要省略关键逻辑
	•	不要引入未说明的第三方库

如果你在实现过程中违反任一架构约束：
	•	立即停止
	•	明确指出违反的约束
	•	重新实现



你现在的角色是“资深前端架构审查与重构顾问（Senior Frontend Architecture Consultant）”。

我将向你提供真实项目代码（可能跨多个 package / module）。
你的任务不是直接给出最终实现代码，而是：

1️⃣ 精确识别当前的依赖关系与违反分层原则的地方  
2️⃣ 明确指出「哪些依赖是架构性问题」，哪些只是实现问题  
3️⃣ 在【不破坏现有系统】的前提下，给出可执行的解决方向（不是抽象建议）

====================
【项目约束（必须严格遵守）】
====================

- 项目采用多 package / monorepo 结构
- common 包：
  - 不能依赖 app（如 crud-app）
  - 不能直接调用获取数据的实现
  - 但业务逻辑上确实需要“数据能力”

- ui package：
  - 是独立 UI 包，可被多个项目复用
  - 不能 import 外部项目的 hook / service
  - 但允许由使用方“注入能力”

- 现有代码已在生产中使用
  - ❌ 不允许大规模重构
  - ❌ 不允许打破现有 API
  - ✅ 允许新增接口层 / Adapter / Provider

====================
【你需要完成的分析任务】
====================

请严格按以下顺序输出：

### Step 1：依赖关系诊断
- 用文字描述当前依赖方向（谁依赖谁）
- 指出违反「依赖反转 / 分层原则」的具体位置（文件或模块级）

### Step 2：问题定性
对每个问题明确说明：
- 是「方向错误」还是「注入方式不当」
- 是否可以通过 Adapter / 注入解决
- 是否属于短期可修复问题

### Step 3：解决方向（重点）
请给出 **2～3 种可行方向**，每种都需要说明：
- 适用场景
- 需要新增的抽象（接口 / 类型 / Provider）
- 对现有代码的侵入程度（低 / 中 / 高）
- 风险点（如初始化顺序、测试、维护成本）

⚠️ 注意：
- 不要直接给我“唯一正确答案”
- 不要假设可以随意改包结构
- 不要引入不必要的第三方库

### Step 4：推荐方案
在前面分析基础上，明确给出你**最推荐的一种方向**，并解释原因：
- 为什么适合当前项目
- 为什么比其他方案风险低
- 后续如何逐步演进（如果需要）

====================
【输出风格要求】
====================

- 使用工程师之间的专业语言
- 偏向“架构评审 / 技术方案评估”
- 避免空泛口号式建议
- 每一个结论都要能追溯到代码或依赖事实

如果你发现我给的代码信息不足：
- 明确指出缺失点
- 说明这些信息会影响哪些判断
- 不要自行假设



// 1. 初始化刷新标记：页面加载/显示时设置为true（刷新会触发，关闭不会）
window.addEventListener('pageshow', (e) => {
  // 排除BF缓存恢复场景，不影响标记
  if (!e.persisted) {
    sessionStorage.setItem('isRefreshing', 'true');
  }
});

// 2. 核心：监听页面卸载，延迟判断是否为关闭（关键：利用刷新的pageshow回调会覆盖）
window.addEventListener('beforeunload', (e) => {
  // 延迟执行：给刷新的pageshow留时间清除标记，关闭则无此步骤
  setTimeout(() => {
    const isRefreshing = sessionStorage.getItem('isRefreshing') === 'true';
    // 仅当「不是刷新」时，执行关闭标签的处理逻辑
    if (!isRefreshing) {
      console.log('✅ 标签页被关闭，执行处理逻辑');
      // 你的关闭处理代码：如清除后端会话、上报埋点、保存临时数据等
      // handleTabClose(); 
    }
    // 无论是否关闭，最后清除标记，避免残留
    sessionStorage.removeItem('isRefreshing');
  }, 0);
});

// 3. 页面加载完成后，重置标记（兜底，避免异常场景残留）
window.addEventListener('load', () => {
  sessionStorage.setItem('isRefreshing', 'false');
});
